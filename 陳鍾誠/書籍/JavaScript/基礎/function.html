<!DOCTYPE html>
  <html>
  <head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.2/katex.min.css">
  <link rel="stylesheet" type="text/css" href="https://ccc-js.github.io/pp6/doc/main.css">
  <!-- 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/atom-one-light.min.css">
  <link rel="stylesheet" type="text/css" href="file:///D:/ccc/js/pp6/doc/main.css"> 
  -->
  </head>
  <body>
  <title></title>
  <header>
    <div style="float:left"><label class="toggle" onclick="toggleSidebar()">≡</label>&nbsp;&nbsp;</div>
    <div style="float:left"><p><a href="../../../../陳鍾誠.html" alt="">陳鍾誠</a> / <a href="../../../書籍.html" alt="">書籍</a> / <a href="../../JavaScript.html" alt="">JavaScript</a> / <a href="../基礎.html" alt="">基礎</a></p>
</div>
  </header>
  <aside>
  <div>
  <h6> <a href="./課程/.html" alt="">課程</a></h6>
<ul>
    <li><a href="./課程/網頁設計.html" alt="">網頁設計</a></li>
    <li><a href="./課程/網站設計.html" alt="">網站設計進階</a></li>
    <li><a href="./課程/計算機結構.html" alt="">計算機結構</a></li>
    <li><a href="./課程/系統程式.html" alt="">系統程式</a></li>
    <li><a href="./課程/人工智慧.html" alt="">人工智慧</a></li>
    <li><a href="./課程/軟體工程.html" alt="">軟體工程</a></li>
</ul>
<h6> <a href="./書籍/.html" alt="">書籍</a></h6>
<ul>
    <li><a href="./書籍/演算法.html" alt="">演算法</a></li>
    <li><a href="./書籍/科學計算.html" alt="">科學計算</a></li>
    <li><a href="./書籍/機率統計.html" alt="">機率統計</a></li>
    <li><a href="./書籍/資料庫.html" alt="">資料庫</a></li>
    <li><a href="./書籍/JavaScript.html" alt="">JavaScript</a></li>
    <li><a href="./書籍/nand2tetris.html" alt="">nand2tetris</a></li>
    <li><a href="./書籍/C語言.html" alt="">C語言</a></li>
    <li><a href="./書籍/Verilog.html" alt="">Verilog</a></li>
    <li><a href="./書籍/圖靈獎.html" alt="">圖靈獎年表</a></li>
</ul>
<h6> <a href="./Home.html" alt="">陳鍾誠</a></h6>
<ul>
    <li><a href="./程式.html" alt="">程式</a></li>
    <li><a href="./作品.html" alt="">作品</a></li>
    <li><a href="./蒐藏.html" alt="">蒐藏</a></li>
</ul>
  </div>
  </aside>
  <article>
  <div class="header">
    
    
    
  </div>
  <h2> JavaScript 的函數</h2>
<p></p>

<h3> 簡介</h3>

<p>當您學會了 if, while 這些控制結構之後，基本上就可以寫出所有的程式了，但是卻沒辦法寫出好的程式。</p>

<p>因為、一個好的程式，必需要有很好的結構。</p>

<p>換句話說、好的程式可以讓我們隨時呼叫其中的功能，讓我們可以不用一再重寫類似的程式碼，就可以透過呼叫其他程式來完成我們想要的工作。</p>

<p>因此我們需要函數！</p>

<p>有了函數，程式就能擁有好的結構，程式就能被模組化，然後輕易的被呼叫，這就是本章的主題：《函數》的用途了！</p>

<p>讓我們先看一個函數的例子，那就是取大值 max(a,b) ，這個函數會傳回 a, b 兩者當中較大的那一個數值。</p>

<h3> 取大值</h3>

<p>檔案：max.js</p>

<pre class="code"><code class="">function max(a,b) {
  if (a&gt;b)
    return a;
  else
    return b;
}

m = max(9,5);
console.log("max(9,5)="+m);
</code></pre>

<p>執行結果：</p>

<pre class="code"><code class="">nqu-192-168-61-142:code mac020$ node max.js
max(9,5)=9
</code></pre>

<p>在此必須說明一點，函數呼叫時，參數的傳遞與名稱無關，而是與參數的位置有關。</p>

<p>舉例而言，上面我們用 max(9,5) 呼叫 max 函數，此時 a, b 分別會帶入 a=9, b=5 的值進去，因此判斷式會得到 if (9>5) return 9; 於是會傳回 9.</p>

<p>但是如果我們用下列的呼叫方式，那麼就會得到 z=7。</p>

<pre class="code"><code class="">x=3; y=7;
z = max(x,y); // 此時 x 會代入 a, y 會代入 b 於是得到 max(x,y) = max(3,7) = 7
</code></pre>

<p>假如呼叫時有 a, b 等變數，也不會因為名稱相同而代入，而是按照位置填入，舉例而言，在以下程式中，</p>

<pre class="code"><code class="">a=8; b=2;
c = max(b,a); // 此時 b=2 會代入參數 a, 而 a=8 會代入參數 b 於是得到 max(b,a) = max(2,8) = 8
</code></pre>

<p>總而言之，函數是根據呼叫時的位置代入的，而非根據名字。</p>

<h3> 計算總和</h3>

<p>您可以在函數裡面使用前面幾章所學到的任何控制結構，像是 if, while, for, switch, 陣列，變數等等。</p>

<p>檔案： fsum.js</p>

<pre class="code"><code class="">
function sum(n) {
  var s=0;
  for (i=1; i&lt;=n; i++) {
    s = s+i;
  }
  return s;
}

sum10 = sum(10);
console.log("1+...+10="+sum10);

</code></pre>

<p>執行結果：</p>

<pre class="code"><code class="">nqu-192-168-61-142:code mac020$ node fsum.js
1+...+10=55
</code></pre>

<h3> 質數測試</h3>

<p>檔案： prime.js</p>

<pre class="code"><code class="">function isPrime(n) {
  for (var i=2; i&lt;n; i++) {
    if (n%i === 0)
      return false;
  }
  return true;
}

console.log("isPrime(33)="+isPrime(33));
console.log("isPrime(17)="+isPrime(17));

for (var p=1; p&lt;=100; p++) {
  if (isPrime(p))
    console.log("isPrime("+p+")");
}

</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">nqu-192-168-61-142:code mac020$ node prime.js
isPrime(33)=false
isPrime(17)=true
isPrime(1)
isPrime(2)
isPrime(3)
isPrime(5)
isPrime(7)
isPrime(11)
isPrime(13)
isPrime(17)
isPrime(19)
isPrime(23)
isPrime(29)
isPrime(31)
isPrime(37)
isPrime(41)
isPrime(43)
isPrime(47)
isPrime(53)
isPrime(59)
isPrime(61)
isPrime(67)
isPrime(71)
isPrime(73)
isPrime(79)
isPrime(83)
isPrime(89)
isPrime(97)
nqu-192-168-61-142:code mac020$ 

</code></pre>

<h3> 匿名函數</h3>

<p>在 JavaScript 當中，函數的宣告方法大致有兩種，第一種的宣告方法就和一般程式語言 (C/C++, Python, Java) 等差不多，是採用 f(a,b,c...) 這種方式宣告的，但是必須在前面加上 function 這個關鍵字。</p>

<p>在以下範例中， sub(a,b) 就是採用這種方式宣告的一個範例。</p>

<p>檔案：function.js</p>

<pre class="code"><code class="javascript">// 第一種寫法，直接宣告函數
function sub(a,b) {         
  return a-b;
}

// 第二種寫法，將匿名函數指定給變數。
var add = function(a,b) {     
  return a+b;
}
console.log("add(3,5)=", add(3,5), " sub(7,2)=", sub(7,2));
</code></pre>

<p>執行結果：</p>

<pre class="code"><code class="">D:\js\code&gt;node function.js
add(3,5)= 8  sub(7,2)= 5
</code></pre>

<p>但是、在 JavaScript 當中，還有一種比較特別函數宣告方式，是在宣告了一個「匿名函數」之後，再把這個函數「塞給」一個變數。就像上述的 <code>var add = function(a,b) ...</code> 的做法，這樣我們就可以用 add(3,5) 這樣的方式去呼叫該函數了。</p>

<p>必須注意的是，函數應該先定義之後再使用，否則有可能會發生《該函數不存在》的問題。</p>

<p>舉例而言，如果你將上述程式</p>

<p>檔案： addUndef.js</p>

<pre class="code"><code class="javascript">console.log("add(3,5)=", add(3,5));

var add = function(a,b) {     
  return a+b;
}
</code></pre>

<p>執行時就會發現有如下的錯誤，這就是因為 add 函數在還沒定義時就被呼叫的原因。</p>

<pre class="code"><code class="">D:\jsbook&gt;node addUndef.js
D:\jsbook\addUndef.js:1
(function (exports, require, module, __filename, __dirname) { console.log("add(3
,5)=", add(3,5));

       ^

TypeError: add is not a function
    at Object.&lt;anonymous&gt; (D:\jsbook\addUndef.js:1:88)
    at Module._compile (module.js:425:26)
    at Object.Module._extensions..js (module.js:432:10)
    at Module.load (module.js:356:32)
    at Function.Module._load (module.js:313:12)
    at Function.Module.runMain (module.js:457:10)
    at startup (node.js:138:18)
    at node.js:974:3
</code></pre>
<p></p>

<h3> 參數的傳遞</h3>

<p>有些人說，javascript 傳遞參數都是採用傳值的方式，這種說法雖然不能說錯，但必須注意一件事。</p>

<p>對於基礎型態，像是數值、布林值等等，是採用傳值的方式，也就是複製一份之後再傳給函數，但是對於像陣列、物件、字串等等，雖然也是複製一份傳給函數，但是複製的卻是其指標，因此對於這些復合結構的物件而言，說白了就是採用傳參照的方式。</p>

<p>參考： <a href="http://heyyou.logdown.com/posts/145054">http://heyyou.logdown.com/posts/145054</a></p>

<p>基本型態的參數，如果你在函數內進行修改，並不會影響外部的那個對應變數，但是如果是物件型態的參數，由於是採用傳參照的方式，這代表兩者其實是參照到同一個物件內容，所以對應的外部變數也會被修改。</p>

<p>以下的範例展示了這兩類參數被修改後的結果：</p>

<p>檔案： modify.js</p>

<pre class="code"><code class="javascript">function modify(num, array) {
  num = num + 1;
  array[0] = array[0] + 1;    
}

var n=3, a=[3,2,1];

modify(n, a);

console.log("n=", n, " a=", a);
</code></pre>

<p>執行結果：</p>

<pre class="code"><code class="">$ node modify
n= 3  a= [ 4, 2, 1 ]
</code></pre>

<h3> 函數型態的參數</h3>

<p>在上面的 add 範例中，我們將「函數」塞給一個變數，而且還可以直接把該變數當作函數來呼叫。</p>

<p>那麼、我們能不能將函數當作參數來傳遞呢？ </p>

<p>關於這點、當然是可以的，以下是一個將「函數當作參數」的範例。</p>

<p>檔案： fptr.js</p>

<pre class="code"><code class="javascript">function sub(a,b) {         
  return a-b;
}

function f5(f, a) {
  return f(a, 5);
}

console.log("sub(8,5)="+sub(8, 5));
console.log("f5(sub,8)="+f5(sub,8));
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\Public\web\js\code&gt;node fptr
sub(8,5)=3
f5(sub,8)=3
</code></pre>

<p>您可以看到，函數 <code>f5(f, a)</code> 的參數 f，其實又是一個函數，因為我們在 f(a,5) 當中把 f 當作函數來呼叫。</p>

<p>所以、當我們呼叫 f5(sub, 8) 的時候，該函數會傳回 3，因為當我們將 f5(sub, 8) 內容中的 f 取代為 sub，而 a 取代為 8 時，就會發現 return 語句的 f(a,5) 其實就是 sub(8,5)，所以當然就會傳回 3 囉！</p>

<h3> 呼叫不特定函數</h3>

<p>既然可以將函數當成參數傳入，那麼我們就可以設計一個如下的 run 函數，該函數在執行完待呼叫函數 f 之後，再把執行結果印出來。</p>

<p>檔案： run.js</p>

<pre class="code"><code class="">function run(f, x) {
  var fx = f(x);
  console.log("f(x)="+fx);
}

run(Math.sin, Math.PI/4);
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\cccweb\db\js\code&gt;node run.js
f(x)=0.7071067811865475
</code></pre>

<h3> 套用函數在陣列中的每個元素上</h3>

<p>透過將函數傳入的方式，我們也可以設計出處理陣列中每個元素的高階函數，舉例而言，以下的 each 函數就是一個範例。</p>

<p>檔案： each.js</p>

<pre class="code"><code class="">function each(a, f) {
  for (var i in a) {
    f(a[i]);
  }
}

each([3,4,5,6], console.log);

function sinPrint(x) {
  console.log("sin(%d)=%d", x, Math.sin(x));
}

each([3,4,5,6], sinPrint);
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\cccweb\db\js\code&gt;node each.js
3
4
5
6
sin(3)=0.1411200080598672
sin(4)=-0.7568024953079282
sin(5)=-0.9589242746631385
sin(6)=-0.27941549819892586
</code></pre>

<p>我們也可以設計出如下的 map 函數將整個陣列套用函數後轉換成另一個陣列。</p>

<p>檔案： map.js</p>

<pre class="code"><code class="">var c = console;

function map(f, a) {
  var ma = [];
  for (var i in a) {
    ma.push(f(a[i]));
  }
  return ma;
}

function square(x) {
  return x*x;
}

c.log("map(x^2, [3, 1, 5, 4, 2])="+map(square, [3,1,5,4,2]));
c.log("map(sin(x), [3, 1, 5, 4, 2])="+map(Math.sin, [3,1,5,4,2]));
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\cccweb\db\js\code&gt;node map.js
map(x^2, [3, 1, 5, 4, 2])=9,1,25,16,4
map(sin(x), [3, 1, 5, 4, 2])=0.1411200080598672,0.8414709848078965,-0.9589242746
631385,-0.7568024953079282,0.9092974268256817
</code></pre>

<h3> 回呼 (callback)</h3>

<p>既然可以將函數當成參數傳入，那麼我們就可以將某個函數傳入，等到某些動作執行完成之後再呼叫該函數，這種方法就稱為回呼 Callback 。</p>

<p>在 node.js 或網頁中，我們常常需要在輸出入動作完成後進行回呼，或者是在某些適當的時機去執行某些函數，這些都可以採用上述的回呼技術來設計。</p>
<p></p>

<h3> 微分</h3>

<p>檔案： df.js</p>

<pre class="code"><code class="">function df(f, x) {
  var dx = 0.001;
  var dy = f(x+dx) - f(x);
  return dy/dx;
}

function square(x) {
  return x*x;
}

console.log('df(x^2,2)='+df(square, 2));
console.log('df(x^2,2)='+df(function(x){ return x*x; }, 2));
console.log('df(sin(x/4),pi/4)='+df(Math.sin, 3.14159/4));
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\cccweb\db\js\code&gt;node df.js
df(x^2,2)=4.000999999999699
df(x^2,2)=4.000999999999699
df(sin(x/4),pi/4)=0.7067535793015001
</code></pre>

<h3> 積分</h3>

<p>檔案： integral.js</p>

<pre class="code"><code class="">function integral(f, a, b) {
  var dx = 0.001;
  var area = 0.0;
  for (var x=a; x&lt;b; x=x+dx) {
    area = area + f(x)*dx;
  }
  return area;
}

function square(x) {
  return x*x;
}

console.log('integral(x^2,0,1)='+integral(square,0,1));
console.log('integral(sin(x),0,pi)='+integral(Math.sin,0,3.14159));
</code></pre>

<p>執行結果</p>

<pre class="code"><code class="">D:\Dropbox\cccweb\db\js\code&gt;node integral.js
integral(x^2,0,1)=0.33283350000000095
integral(sin(x),0,pi)=1.9999999540411524
</code></pre>

<h3> 箭頭函數</h3>

<p>以下的 square2 採用箭頭函數進行回呼！</p>

<pre class="code"><code class="js">var numbers = [1, 4, 9]
var square1 = numbers.map(function (num) {
  return num * num
})

var square2 = numbers.map((num) =&gt; num * num)

console.log('square1=%j', square1)
console.log('square2=%j', square2)
</code></pre>

<h3> 亂數: 取 (a,b) 範圍間的亂數 (浮點數版 -- rand)</h3>

<pre class="code"><code class="">$ node
&gt; function rand(a,b) { return a+Math.random*(b-a); }
undefined
&gt; rand(1,10)
NaN
&gt; function rand(a,b) { return a+Math.random()*(b-a); }
undefined
&gt; rand(1,10)
9.309291471494362
&gt; rand(1,10)
3.008262322982773
&gt; rand(1,10)
3.473059037467465
</code></pre>
<p></p>

<h3> 取 (a,b) 範圍間的亂數 (整數版 -- randInt)</h3>

<pre class="code"><code class="">$ node
&gt; function randInt(a,b) { return Math.floor(a+Math.random()*(b-a)); }
undefined
&gt; randInt(1,10)
4
&gt; randInt(1,10)
5
&gt; 
&gt; randInt(1,10)
7
&gt; randInt(1,10)
2
&gt; randInt(1,10)
2
&gt; randInt(1,10)
8
&gt; randInt(1,10)
3
&gt; randInt(1,10)
1
&gt;
</code></pre>

<h3> 從陣列中隨機選擇一個元素 randSelect(a)</h3>

<pre class="code"><code class="">$ node
&gt; function randSelect(a) { return a[randInt(0,a.length)]; }
undefined
&gt; randSelect([1,7,4])
1
&gt; randSelect([1,7,4])
1
&gt; randSelect([1,7,4])
4
&gt; randSelect([1,7,4])
7
&gt; randSelect([1,7,4])
7
&gt; function randSelect(a) { return a[randInt(0,a.length)]; }
undefined
&gt; randSelect([1,7,4])
4
&gt; randSelect(['a','g','c'])
'a'
&gt; randSelect(['a','g','c'])
'c'
&gt; randSelect(['a','g','c'])
'a'
&gt; randSelect(['a','g','c'])
'g'
&gt; randSelect(['a','g','c'])
'g'
&gt; randSelect(['a','g','c'])
'g'
&gt; randSelect(['dog','cat'])
'cat'
&gt; randSelect(['dog','cat'])
'dog'
&gt; randSelect(['dog','cat'])
'cat'
&gt; randSelect(['dog','cat'])
'cat'
&gt; randSelect(['dog','cat'])
'dog'
&gt; randSelect(['dog','cat'])
'cat'
</code></pre>

<h3> 習題</h3>

<p>關於基本函數呼叫的練習，請看第3章的習題！</p>

<p>請您在已經熟練第3章的基本函數之後，再回來做本章的習題，因為這些習題屬於比較進階的議題，必須有第3章的習題作為基礎。</p>

<h3> 回呼函數實作</h3>
<ol>
    <li>請寫一個函數可以傳回陣列的映射值？ </li>
    <ul>
        <li>範例：map(sqrt, [1,4,9])= [1,2,3]</li>
    </ul>
    <li>請寫一個函數可以根據過濾函數f只留下符合的內容？ </li>
    <ul>
        <li>範例：filter(odd, [1,3,5,4,8,9])= [1,3,5,9] ，其中 odd 為判斷是否為奇數的函數。</li>
    </ul>
    <li>請寫一個函數 df(f,x) 可以做數值微分？ </li>
    <ul>
        <li>範例： df(sin, Pi/4) = 0.707 </li>
    </ul>
    <li>請寫一個函數 integral(f, a, b) 可以做數值積分？ </li>
    <ul>
        <li>範例： integral(sin, 0, Pi) = 2</li>
    </ul>
</ol>
<h3> 遞迴呼叫練習</h3>
<ol>
    <li>請用遞迴計算 n! = n<strong>...</strong>2*1 ？ </li>
    <ul>
        <li>範例： factorial(3) = 6</li>
    </ul>
    <li>請寫出計算遞迴函數 <code>f(n) = 2*f(n-1)+f(n-2)</code> 的函數，其中 f(0)=f(1)=1？ </li>
    <ul>
        <li>範例： <code>f(2) = 2*1+1 = 3, f(3)=2*3+1=7</code> 。</li>
    </ul>
    <li>請用遞迴計算 power(n,k) = n^k = n<strong>...</strong>n ？ </li>
    <ul>
        <li>範例：power(2,3) = 8</li>
    </ul>
    <li>請用遞迴計算 sum(n) = 1+2+...+n  ？ </li>
    <ul>
        <li>範例：sum(10) = 55</li>
    </ul>
</ol>
<p>除了學習《程式技巧》之外，更重要的是學習《程式的邏輯思維》。</p>

<p>所謂的《演算法》，就是將程式抽象化之後的那種方法，換言之就是《程式的邏輯思維方法》，以下習題可以鍛鍊學習者的《程式邏輯思維能力》，但是相對的會需要比較深度的思考，才能想出這些程式的實作方法。</p>

<h3> 演算法思考練習</h3>
<ol>
    <li>求一元二次方程式 ax^2+bx+c=0 的根。 </li>
    <ul>
        <li>範例： findroot(1,-4,4) => 2</li>
    </ul>
    <li>請寫出 minimal 函數可以找出函數 f 的區域最低點。 </li>
    <ul>
        <li>範例： <code>function f(x) { return x*x-4*x+4; } minimal(f) =&gt; x=2, f(2)=0</code></li>
    </ul>
    <li>請寫出 maximal 函數可以找出函數 f 的區域最高點。 </li>
    <ul>
        <li>範例： <code>function f(x) { return -1*(x*x-4*x+4); } maximal(f) =&gt; x=2, f(2)=0</code></li>
    </ul>
    <li>電腦隨機產生一個 <code>n*n</code> 的二維布爾值陣列。用程式檢驗該二維字元陣列中，縱行、橫列及兩條對角線，「O(true)的bingo線」及「X(false)的bingo線」分別有多少條。</li>
    <ul>
        <li>輸入 input：一個隨機產生的尺寸 <code>n*n</code> 之二維 Boolean 陣列；</li>
        <li>輸出 output：兩個 integers 。</li>
    </ul>
    <li>請上網查詢何謂《泡沫排序法》，然後寫一個 javascript 程式可以用《泡沫排序法》對陣列進行排序。</li>
    <ul>
        <li>範例： bobbleSort([1,7,2,8,5]) => [1,2,5,7,8]</li>
    </ul>
</ol>
  <div class="reference">
  
  </div>
  </article>
  <footer><p><a href="http://www.nqu.edu.tw/educsie/index.php?act=blog&code=list&ids=4" alt="">陳鍾誠</a> 於 <a href="http://www.nqu.edu.tw/" alt="">金門大學</a> <a href="http://www.nqu.edu.tw/educsie/index.php" alt="">資訊工程系</a> -- 本書衍生自 <a href="https://www.wikipedia.org/" alt="">維基百科</a> ，採用 <a href="https://zh.wikipedia.org/zh-hant/Wikipedia%3ACC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" alt="">CC: BY-SA</a> 授權</p>
</footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.2/katex.min.js"></script>
  <script src="https://ccc-js.github.io/pp6/doc/main.js"></script>
  <!--
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
  <script src="file:///D:/ccc/js/pp6/doc/main.js"></script>
  -->
  </script>
  </body>
  </html>
  